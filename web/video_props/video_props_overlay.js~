import { app } from "../../../scripts/app.js";


// Простая функция вычисления кадров и финальной длительности, дублирующая логику бэкенда
function computeFrames(duration, fps) {
    const frames = 1 + Math.ceil((duration * fps) / 4) * 4;
    const durationFinal = Math.round((frames / fps) * 100) / 100;
    return { frames, durationFinal };
}

// Безопасное чтение значения из виджета по имени
function getWidgetValueByName(node, name, def = null) {
    try {
        const w = node.widgets?.find?.(w => w.name === name);
        return w?.value ?? def;
    } catch (e) {
        return def;
    }
}

// Рендер текста со стилями
function drawText(ctx, text, x, y, opts = {}) {
    const { color = "#9aa0a6", font = "12px sans-serif", align = "left" } = opts;
    ctx.save();
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textAlign = align;
    ctx.fillText(text, x, y);
    ctx.restore();
}

app.registerExtension({
    name: "LoSetVideoPropsOverlay",
    async beforeRegisterNodeDef(nodeType, nodeData, appInst) {
        if (nodeData.name !== "LoSetVideoProps") return;

        // Хелпер: построить строки оверлея из числовых значений
        function buildOverlayLines(width, height, duration, fps) {
            const pixels = width * height;
            const { frames, durationFinal } = computeFrames(duration, fps);
            const pixelsStr = pixels > 1000 * 1000
                ? `${(pixels / 1000 / 1000).toFixed(2)}Mpx`
                : pixels > 1000
                    ? `${(pixels / 1000).toFixed(2)}Kpx`
                    : `${pixels}px`;
            return [
                `size: ${width}x${height} ${pixelsStr}`,
                `duration: ${duration}s`,
                `fps: ${fps}`,
                `frames: ${frames} → ${durationFinal}s`,
            ];
        }

        const originalOnDrawForeground = nodeType.prototype.onDrawForeground;
        const originalOnExecuted = nodeType.prototype.onExecuted;

        // Попытаться извлечь значения width/height/duration/fps из результата выполнения узла
        function extractValuesFromExecutionResult(execResult) {
            if (!execResult) return null;

            // Вариант 1: объект с нужными полями
            if (typeof execResult === "object" && !Array.isArray(execResult)) {
                const maybeWidth = Number(execResult.width);
                const maybeHeight = Number(execResult.height);
                const maybeDuration = Number(execResult.duration);
                const maybeFps = Number(execResult.fps);
                if (
                    Number.isFinite(maybeWidth) && maybeWidth > 0 &&
                    Number.isFinite(maybeHeight) && maybeHeight > 0 &&
                    Number.isFinite(maybeDuration) && maybeDuration > 0 &&
                    Number.isFinite(maybeFps) && maybeFps > 0
                ) {
                    return { width: maybeWidth, height: maybeHeight, duration: maybeDuration, fps: maybeFps };
                }

                // Вариант 1b: вложенный объект video_props
                const vp = execResult.video_props;
                if (vp && typeof vp === "object") {
                    const w = Number(vp.width);
                    const h = Number(vp.height);
                    const d = Number(vp.duration);
                    const f = Number(vp.fps);
                    if (w > 0 && h > 0 && d > 0 && f > 0) return { width: w, height: h, duration: d, fps: f };
                }
            }

            // Вариант 2: массив значений [width, height, duration, fps, ...]
            if (Array.isArray(execResult) && execResult.length >= 4) {
                const w = Number(execResult[0]);
                const h = Number(execResult[1]);
                const d = Number(execResult[2]);
                const f = Number(execResult[3]);
                if (w > 0 && h > 0 && d > 0 && f > 0) return { width: w, height: h, duration: d, fps: f };
            }

            return null;
        }

        // Пересчёт и сохранение данных оверлея из текущих значений виджетов
        function updateOverlayFromWidgets() {
            const width = Number(getWidgetValueByName(this, "width", 0)) || 0;
            const height = Number(getWidgetValueByName(this, "height", 0)) || 0;
            const duration = Number(getWidgetValueByName(this, "duration", 0)) || 0;
            const fps = Number(getWidgetValueByName(this, "fps", 0)) || 0;
            if (width > 0 && height > 0 && duration > 0 && fps > 0) {
                this.__lo_overlayLines = buildOverlayLines(width, height, duration, fps);
            } else {
                this.__lo_overlayLines = null;
            }
        }

        // Вызывается после выполнения узла: обновляем оверлей по пришедшим параметрам и перерисовываем
        nodeType.prototype.onExecuted = function () {
            try {
                // Пытаемся взять фактические значения из результата выполнения (они учитывают переопределения по линкам)
                const execResult = arguments && arguments.length ? arguments[0] : undefined;
                const values = extractValuesFromExecutionResult(execResult);
                if (values) {
                    const { width, height, duration, fps } = values;
                    this.__lo_overlayLines = buildOverlayLines(width, height, duration, fps);
                } else {
                    // Фоллбек: считаем из виджетов
                    updateOverlayFromWidgets.call(this);
                }
                this.setDirtyCanvas(true, true);
            } catch (e) {
                //
            }
            if (originalOnExecuted) return originalOnExecuted.apply(this, arguments);
        };

        nodeType.prototype.onDrawForeground = function (ctx) {
            // Вызов оригинала, если был
            if (originalOnDrawForeground) originalOnDrawForeground.apply(this, arguments);

            // Если уже есть рассчитанные строки (например, после onExecuted) — используем их
            let lines = this.__lo_overlayLines;
            // Иначе, пробуем посчитать из текущих значений виджетов (живой предпросмотр)
            if (!lines) {
                const width = Number(getWidgetValueByName(this, "width", 0)) || 0;
                const height = Number(getWidgetValueByName(this, "height", 0)) || 0;
                const duration = Number(getWidgetValueByName(this, "duration", 0)) || 0;
                const fps = Number(getWidgetValueByName(this, "fps", 0)) || 0;
                if (width > 0 && height > 0 && duration > 0 && fps > 0) {
                    lines = buildOverlayLines(width, height, duration, fps);
                }
            }

            if (!lines) return;

            // Позиционирование: рисуем у нижнего края, с отступами
            const padding = 8;
            const lineHeight = 15;
            const x = padding;
            const y = padding*2.5;

            // Текст (правое выравнивание в подложке)
            for (let i = 0; i < lines.length; i++) {
                drawText(ctx, lines[i], x, y + i * lineHeight, { align: "left" });
            }
        };
    },
});


